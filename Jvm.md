### 双亲委派模型
- 类加载的生命周期  
 - 加载 验证 准备 解析 初始化 使用 卸载
    - 验证 准备 解析  -> 连接
    - 加载 
      > 三个步骤 通过全类名获取此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法去的运行时数据结构， 内存中生成一个对应的class对象
    - 验证 
      > 1.文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头（当class文件以二进制形式打开，会看到这个文件头，cafebabe）、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
      > 2. 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外
      > 3.字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
      > 4.符号引用验证：确保解析动作能正确执行。
    - 准备
      > 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值通常情况下是数据类型的零值。
    - 解析
        > 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。
    - 初始化
        > 
- 双亲委派机制 
 - 类加载器收到加载请求的时候，先委托给父类加载器，加载不到，委托给子类
 - 等级 
    - BootStrap ClassLoader
        > Bootstrap ClassLoader:这个加载器不是一个Java类，而是由底层的c++实现，负责在虚拟机启动时加载Jdk核心类库（如：rt.jar、resources.jar、charsets.jar等）以及加载后两个类加载器。这个ClassLoader完全是JVM自己控制的，需要加载哪个类，怎么加载都是由JVM自己控制，别人也访问不到这个类
    - ExtClassLoader
        > Extension ClassLoader:是一个普通的Java类，继承自ClassLoader类，负责加载{JAVA_HOME}/jre/lib/ext/目录下的所有jar包。
    - AppClassLoader
        >App ClassLoader：是Extension ClassLoader的子对象，负责加载应用程序classpath目录下的所有jar和class文件。
 - 类加载的两种方式
    - 形式上类似于Class.forName(name,true,currentLoader)。 综上所述，Class.forName 如果调用成功会初始化数据
    - ClassLoader.loadClass 只是装载class，不初始化
    - 通过synchroized防止并发
- 破坏双亲委派模型
    - 原因 父类加载器无法加载子类中的实现类，所以启用了SPI
    > 因为类加载器受到加载范围的限制，在某些情况下父类加载器无法加载到需要的文件，这时候就需要委托子类加载器去加载class文件。
    - 从META-INFO/services/获取实现
- 线程上下文类加载器让父级类加载器能通过调用子级类加载器来加载类，这打破了双亲委派模型的原则
    - 也是为了解决接口对实现的依赖，要不然必须要调用方自己指定实现类， 比如driverManage 在rt里，但是通过ServiceLoader，可以借助TCCL获取AppClassLoader的类信息
        - 还有tomcat，有多类型的依赖包，所以区分类加载器，来做隔离，
        - OSGi 模块化编程，做到组件热插拔，所以classLoader是网状结构
        - java9 就是做模块化加载，加载不到才会进行双亲委派
    - 或者重新findClass方法，这是jdk1.2对之前做的兼容

- java内存区域
    - 方法区
    > 之前使用永久代实现，现在使用元空间，还有运行时常量池
    - 虚拟机栈
    > 每个方法在执行的同时都会创建一个栈帧，每个栈帧存放局部变量表 操作数栈，动态链接，方法出口，每个方法执行的时候都会创建一个栈
    - 本地方法栈
    > 基本等同虚拟机栈，只是调用的是native方法
    - 堆
    > yong 1/3 old 2/3
    > 新生代 8/10 是eden survivor0 和survivor1各占1/10
    > 永久代，存放Class信息，常量，静态变量，JIT代码，基本不进行垃圾回收
    - 程序计数器
    > 当前线程执行的字节码的行号指示器。不会OOM
    - 1.7 1.8 元数据替换永久代，这样直接使用本地内存，而不是虚拟机内存

- 对象分配
    - 新生代 Eden去分配内存
    - 如何进入老年代
    > 按年龄，Gc的时候进入老年代
    > 大对象
    > Survivor相同年龄的对象大小总和大于survivor空间一半，年龄大于等于改年龄的直接进入老年代
    - minor gc一次，eden就进入surivor区 
        - to区放的是未可进入的对象，比如Eden区过来的，或者from区gc不可进入old的对象，gc过后，from区清空，变成to，to区上升到from区

- 判断内存是否需要回收
    - 引用计数法  无法解决循环引用
    - 可达性分析算法，
    > 基于图的算法，把每一个对象当作图中的一个节点，我们把一个节点叫做GC Roots，如果一个节点到GC Roots没有任何相连路径，哪么说明这个节点不可达
    > GCRoots对象 虚拟机栈中的局部变量表 方法中的静态属性 常量 Native引用对象
    > 回收时机 先判断需不需要执行finaliza()方法，需要的化，放进F-QUEUE队列中等待执行，如果此时不想被执行，就把当前对象的引用逃逸出去

- 回收算法
    - 标记清除
    > 标记并清除  存在内存碎片 还有效率问题
    - 标记整理
    > 标记，整理，把存活的对象向一个方向移动
    - 复制算法
    > 对半回收，用一半，复制，清除掉
    - 分代回收
    > 新生代适合复制  老年代做标记清楚标记整理

- 垃圾回收器
    - Serial
    > 单线程垃圾回收器，采用 新生到 复制算法  响应速度优先
    - Serial Old
    > 单线程 标记整理 处理老年代 响应速度优先
    - ParNew
    > 多线程版本Serial垃圾回收器 处理新生代为主 响应速度优先 多线程下表现好
    - Parallel Scavenge
    > 多线程回收期 使用复制算法 处理新生代内存 到一个可控制的吞吐量即可 
    - Parallel Old
    > 多线程回收期 使用标记整理 处理老年代内存 到一个可控制的吞吐量即可 
    - CMS   
      >  1. 初始标记 stw  只是标记一下和GC Roots直接相关联的对象 
      >  2. 并发标记 GCRoots tracing 寻找出所有的对象
      >  3. 重新标记 stw 标记一下标记发生变动的变量
      >  4. 并发清除
      - 使用了标记清除 产生了内存碎片 ，但是使用标记整理，会影响用户线程使用
      - remark 停顿时间比较长 并发标记的时候其实并不会停顿 
      - promotion failed 
        > 碎片导致放入老年代失败产生的异常
      - concurrent mode failure 
        > promotion failed时，老年代正在full gc 基本等于浮动垃圾难以处理
      - 对CPU数量依赖高
    - G1
        - 高效益优先。G1会预测垃圾回收的停顿时间，原理是计算老年代对象的效益率，优先回收最大效益的对象。
        - 堆内存结构的不同。G1则是把内存分为多个大小相同的区域Region，每个Region拥有各自的分代属性，但这些分代不需要连续。
        - 内存根节点放入rememberdbered set减少全面扫描
        - 初始标记 stw
        - 并发标记
        - 最终标记
        - 筛选回收 对每个regin的回收价值进行排序，根据期望GC停顿时间指定回收计划

    - ZGC
        -

- jMM
    - 屏蔽硬件和内存访问差异，
    - 所有变量都在主内存，线程不能直接操作主内存
    - 定义了三个特性
        - 原子性
        > 只保证单个操作的原子性
        - 可见性
        > 基于 volatile ，被volatile修饰的，写的时候直接写入主内存，或者基于synchroized来保证，final字段初始化后对所有线程可见
        - 有序性
        > 使用Volitale 保证不进行执行重排序，synchroized保证每个同步块之间是有序的
    - 内存的八种操作
        - lock 把主内存变量标记为线程独占状态
        - read 把主内存变量读取到当前线程的工作内存
        - load read到的主内存数据，加载到工作内存上
        - use 把工作内存的数据，传输到虚拟机栈上
        - assign 把栈的数据，送到工作内存上
        - store 把工作内存的变量，传送给主内存
        - write 主内存存储拿到的变量
        - unlock 解锁主内存线程独占的变量
    - 内存交互操作原则
        - read load  store write必须组合出现
        - 不允许线程丢弃他最近的assign操作
        - 不允许将没assign的数据加载到主内存
        - 一个新的变量必须产生在主内存，不允许工作内存使用一个未初始化的变量
        - 一个变量同一时间只能有一个线程同时对他进行lock操作。多次lock之后，必须执行对应相同次数的unkock
        - 对一个变量进行lock操作，会清空工作内存中对应的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值
        - 如果一个变量没有lock，就不能进行对应的unlock操作，也不能unlock别的线程lock的数据
        - 对变量进行unlock之前，必须先回写主内存
    - volatile
        - 保证线程间变量可见性
        > volatile修改的变量，当一个线程改变了它的值，其他线程是立刻可见的。普通变量需要重新读取
        > 不能保证线程安全，因为不能保证原子性
        - 禁止CPU进行指令重排序
        > 为了使指令更加符合CPU的执行特性，最大限度的发挥机器的性能，提高程序的执行效率，只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码逻辑顺序不一致，这个过程就叫做指令的重排序。 但是多线程协同，就需要禁止指令重排序
        > 通过加入内存屏障，来防止指令重排序
        > loadload storestore loadstore storeload
        > 加入对应的读写屏障，保证指令执行顺序
        > 读操作前放入 loadload 操作之后放入 loadstore
        > 写操作前放入 storestore 操作之后放入 storeload
        - happens before 前一个操作的结果，对后一个可见
        > 程序顺序规则
        > 监视器锁规则
        > volatile变量规则 A线程
        > 传递规则
        > start()规则 
        > join规则 所有终止检测操作都先于对此线程的终止检测
        > 中断原则 对中断的调用一定在检测到中断事件之前
        > 对象终结规则 调用finalize方法前，一定执行了初始化代码