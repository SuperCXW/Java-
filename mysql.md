# mysql
## 结构
1. 连接层：最上层是一些客户端和连接服务。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。
2. 服务层：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等
3. 引擎层：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取
4. 存储层：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互

## 执行流程
1. 客户端请求
2. 连接器接受请求 验证身份，授权
3. 查询缓存
4. 分析器 sql解析 语法分析 词法分析
5. 优化器 对sql选择最优执行方案
6. 执行器 ACL
7. 引擎层查询数据
![avatar](./pic/数据库存储结构.png)  

## 存储引擎
1. 可插拔的存储引擎体系结构
```
-- 查看支持的存储引擎
SHOW ENGINES

-- 查看默认存储引擎
SHOW VARIABLES LIKE 'storage_engine'

--查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！
show create table tablename

--准确查看某个数据库中的某一表所使用的存储引擎
show table status like 'tablename'
show table status from database where name="tablename"

-- 建表时指定存储引擎。默认的就是INNODB，不需要设置
CREATE TABLE t1 (i INT) ENGINE = INNODB;
CREATE TABLE t2 (i INT) ENGINE = CSV;
CREATE TABLE t3 (i INT) ENGINE = MEMORY;

-- 修改存储引擎
ALTER TABLE t ENGINE = InnoDB;

-- 修改默认存储引擎，也可以在配置文件my.cnf中修改默认引擎
SET default_storage_engine=NDBCLUSTER;

```
2. 常见存储引擎  
    - innodb
    - myisam
    - memory

3. 文件存储结构对比
  > 在 MySQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的 .frm 文件，.frm 文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有.frm文件，命名方式为 数据表名.frm，如user.frm。
  查看MySQL 数据保存在哪里：show variables like 'data%'  
    MyISAM 物理文件结构为：
    .frm文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等
    .MYD (MYData) 文件：MyISAM 存储引擎专用，用于存储MyISAM 表的数据
    .MYI (MYIndex)文件：MyISAM 存储引擎专用，用于存储MyISAM 表的索引相关信      息
    InnoDB 物理文件结构为：
    .frm 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等
    .ibd 文件或 .ibdata 文件： 这两种文件都是存放 InnoDB 数据的文件，之所以     有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配   置来决定是使用共享表空间存放存储数据，还是用独享表空间存放存储数据。
    独享表空间存储方式使用.ibd文件，并且每个表一个.ibd文件
    共享表空间存储方式使用.ibdata文件，所有表共同使用一个.ibdata文件（或多      个，可自己配置）

    - innoDb支持事务，myisam不支持
    - innodb有表锁也有行锁，myisam只有表锁，并发场景下性能不够
    - innodb支持外建，myisam不支持
    - innodb是聚簇索引，myisam是非聚簇索引
        > 聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
    - innodb不保存表具体的行数，myisam用了一个变量来维护
        > 为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。
    - 一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15？
        > 如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；
          如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。

## 数据类型
   1. varchar 和char的区别
        - varchar只是确认最大长度，char直接分配对应空间
        - 存储最大长度不一样， 一个255 一个65537 
        - char存储截断尾部的空格 varchar不会
        - 超过长度都会截断

## 索引
1. 对索引的理解
    > 帮助mysql高效查询数据的数据结构 提高查询效率
    > 以文件形式存储在磁盘上
    > 优点 提高查询效率 缺点 提高储存的时间成本，空间成本
2. 索引分类
    -  B+树索引 B树索引 Full-text R-tree索引  
    -  聚簇索引 非聚簇索引（辅助索引）
    -  主键索引 普通索引 复合索引 唯一索引 空间索引

3. B && B+ Tree
    - B树是为磁盘等外部存储设备设计的一种平衡查找树。
    - 系统从磁盘读取数据到内存是以磁盘块（block）为单位的，位于同一个block的数据会被一次性读取出来。而不是需要什么读取什么
    - innodb有页的概念，页是磁盘管理的最小单位，innodb存储引擎种默认每个页的大小为16KB，而系统磁盘一个block的大小往往没这么大，所以每次innodb读取磁盘数据都会是连续的磁盘块来达到页的大小16KB。innodb在把磁盘数据读入到磁盘时会以页为单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将减小io次数，提高查询效率
    - B树的结构可以让系统高效的找到数据所在的磁盘块。为了描述b树，首先定一个一个记录为一个二元组[key, data] ,key是记录的键值，对应一条数据的主键，data为一行记录中除主键外数据。对于不同的记录，key值各不相同。
    - 一棵m阶B树有以下特性
        > 每个节点最多有m个孩子  
        > 除了根节点和叶子结点外，其它每个节点至少有Ceil(m/2)个孩子  
        > 若根节点不是叶子结点，则至少有两个孩子  
        > 所有叶子结点都在同一层，且不包含其它关键字信息  
        > 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）    
        > n满足ceil(m/2) -1 <= n <= m-1  
        > ki(i=1,…n)为关键字，且关键字升序排序  
        > Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)    
        > B树每个节点根据实际情况可以包含大量的关键字信息和分支，如图![avatar](./pic/Btree.png)    
        > 每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。

    - B+ 树是在B树上的一种优化，B树在每个节点，不光存储数据的key还有data，一个页能存储的key就变少了，数据太多，就导致深度太深，I/O次数多，所以B+tree，把所有的data都按照key的顺序放在同一层的叶子结点上，非叶子节点只存储key的信息，这样子每个节点可以存储的key数量，降低树的高度
        > 与B树的不同:非叶子结点只存储key 所有非叶子节点都有一个链指针 数据都在叶子节点 ![avatar](./pic/B+tree.png)    
    - 通常在B+tree上有两个头指针,一个指向根节点,另一个指向关键字最小的叶子节点,而且所有的叶子结点之间是一种链式结构.因此可以对B+tree进行两种查找,一种是对于主键的范围查找和分页查找,另一种是从跟节点开始,随机查找

    - InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。而B树因为数据也在非叶子结点上,就没法保证这么多记录
    实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。

    - 通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。

    - 当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

    - myisam
        > MyISAM主键索引与辅助索引的结构
            MyISAM引擎的索引文件和数据文件是分离的。MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址。索引文件与数据文件分离，这样的索引称为"非聚簇索引"。MyISAM的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字。
    - innodb
        > InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行），或者说，InnoDB的数据文件本身就是主键索引文件，这样的索引被称为"“聚簇索引”，一个表只能有一个聚簇索引。
    - 为什么用整型自增主键 而不是uuid
        > 节约空间
        > 查找时会进行key值比较,整型效率更高
        > 自增的整形索引在磁盘中会连续存储,在读取一页数据时也会连续,UUID随机产生,读取上下两行的数据存储是分散的,不适合执行  where id > 5 && id < 20的条件查询语句
        > 在插入或删除数据时,整型自增主键会在叶子节点的末尾建立新的叶子结点,不会破坏左侧子树的结构,UUID很容易出现这种情况,B+树为了维护自身特性,可能会进行结构的重构,消耗更多的时间
    - 为什么索引树存储的是主键索引
        > 保持数据一致性 和节约存储空间