1. redis压力大
2. 序列化的作用
3. dubbo机制
4. mvcc
5. SynchronousQueue使用场景
6. 幂等性怎么解决
7. 线程安全的List Map 其他List
8. spring循环依赖
9. redis快的原因
10. redis多线程在哪儿
11. 自我介绍
12. 最有技术难度的一件事儿
13. java8特性
14. 乐观锁，悲观锁
15. 云原生
16. redis最新版本
17. 学习途径
18. 分工
19. 写一个sql  查一个班成绩前10名学生，设计一下sql
20. 请设计一个类似微信抢红包系统
21. map的区别与使用场景：hashMap concurrentHashMap  LinkedHashMap  treeMap
22. hashtable与concurrentHashMap的变种？为什么concurrentHashMap查询效率要高于hashtable
23. 讲一讲java并发控制的几个关键字 volitile syschronsize cas
24. java多线程的几个包几个类了解吗?使用场景
reentrolocak  countdownlatch semephore syclebarrier
25. 双亲委派类加载：
26. 线程池参数如何设置：
27. lru的缺点：LRU(Least Recently Used ):淘汰最后被访问时间最久的元素。
缺点：可能会由于一次冷数据的批量查询而误导大量热点的数据。
LFU(Least Frequently Used)：淘汰最近访问频率最小的元素。
缺点：1. 最新加入的数据常常会被踢除，因为其起始方法次数少。 2. 如果频率时间度量是1小时，则平均一天每个小时内的访问频率1000的热点数据可能会被2个小时的一段时间内的访问频率是1001的数据剔除掉 
28. hash一致性协议：
29. oauth2
30. 高可用实现
31. 限流
32. 降级
33. spring bean的生命周期
34. spring 循环依赖
35. redis单线程，所有的方法是不是线程安全的
36. 是不是单线程就是线程安全
37. redis保证性能的方式
38. redis的NIO
39. memcache和redis区别 redis底层怎么分配内存
40. 1.8 中hashmap的改进
41. ArrayList.sort使用的排序算法
42. 快排双指针优化
43. foreach删除  iterator
44. 秒杀系统
45. 怎么设计底层接口表
46. lamada
47. 常见的单例
48. volitile
