# 并发编程
![并发包结构](./pic/J.U.C_2.png)

### 多线程创建
- Thread
- Runnable
- Callable
#### 锁
- synchroized
  可以修饰
  - 方法
  - 对象
  - 类
  - 静态方法
  方法和对象锁住对象锁
  类和静态方法段获得类锁
- Lock
- Reentrant
- ReentrantReadWriteLock
- StampedLock
- AbstractQueuedSynchronizer(AQS)

| 12 | 121 | sds |  
|:-- |:-- | :--|  
| 12 | 121 | sds |  
| 12 | 121 | sds |  
| 12 | 121 | sds |  
#### J.U.C
- atmoic
- locks
- collections
- Executor
  - ForkJoin
  - ThreadPoolExecutor
  - Executors
- sync
#### 并发的三个核心
- 分工
- 合并 
- 互斥  
  + 原子性  
    * 加锁
  + 有序性  
    * 编译器优化顺序影响有序性
      >
  + 可见性  
    * JMM  
      > 这里引入了JMM(Java Memeory Model) java内存模型，这个模型规定 变量都是放在主内存里面，线程修改的时候，要copy一个副本，这个副本修改完成后，刷新回主内存  
      >> 这里引入了一个并发问题，就是A拿走了，改了数据，B拿到的是没会写前的数据，这样就会发生可见性问题  
      >>>Happens-Before  
      >>>第一个操作的结果，对第二个数据可见
      >>>>程序顺序性规则  
      >>>>volatile变量规则  
      >>>>传递性规则  
      >>>>监视器锁规则  
      >>>>start()规则  
      >>>>join()规则  

      >> 内存屏障保护实现有序性，防止重排序
      >>> volatile写前插入一个storestore屏障
      >>> volatile写后插入一个storeLoad屏障`
      >>> volatile读前插入一个loadLoad屏障
      >>> volatile读后插入一个loadStore屏障
      >>>写一个volatile变量，实际上是向其他要读这个变量的线程发消息，让他们去主内存读
  + synchroized 只能保护当前对象，无法保护目标对象，这时候就需要锁整个class
    > 锁 普通同步方法,锁的是当前实例对象  静态方法,锁整个class   同步代码块，锁括号里面的obj
    
  + volatile 不保障原子性，所以写入值不依赖原址时，可以使用
  + 死锁
    - 条件
      >互斥  这个资源，只有唯一线程占用，排斥其他线程的占用  
      >请求和保持条件 持有一个资源，同时请求下一个资源，该资源已被其他线程持有  
      >不可剥夺条件 不使用完，不释放   
      >环路等待 必然存在进程，资源，环形链，所需的资源必然画成一个环  
      
      >> 可以尝试破坏 后三个条件
  + 等待/唤醒   
    + 管程
    > 管理共享变量以及对共享变量的操作，让他们支持并发
    >>数据和操作，一起入列enq 出列deq，多线程执行只能通过队列排队执行，入列出列，本身是互斥的
    > 通过另外的变量，来保证资源由同一线程持有
    ```
    sychroized() {
      while(m) {
        obj.wait
      }
    }

    sychroized() {
      while(m) {
        obj.notyfy()
      }
    }

    ```
 
    + MESA模型
    > 

    + 线程的生命周期
    > 操作系统
    ```
      初始
      可运行
      运行中
      阻断
      结束
     ```
    > jvm 
    ```
      NEW
      RUNNABLE
      BLOCKED
      WAITING
      TIME_WAITING
      TERMINATED
    ```
  + 中断 
    > Thread.interrupt() 中断自己或者其他线程，底层依赖native方法 
    >> 当线程在wait join sleep 被中断，会抛出InterruptException异常

    > Thread.isInterrupted() 判断线程是否中断 

    > Thread.interrupted() 清空中断标识，只有当前存在中断标志，才会返回true，否则返回false

    > 原则
    >> 如果遇到的是可中断的阻塞方法, 并抛出 InterruptedException，可以继续向方法调用栈的上层抛出该异常；如果检测到中断，则可清除中断状态并抛出 InterruptedException，使当前方法也成为一个可中断的方法

    >> 若有时候不太方便在方法上抛出 InterruptedException，比如要实现的某个接口中的方法签名上没有 throws InterruptedException，这时就可以捕获可中断方法的 InterruptedException 并通过 Thread.currentThread.interrupt() 来重新设置中断状态。

### Lock锁 
  - 因为synchronized不能及时退出锁，控制锁的状态  
  - 新的接口 
    - lock()  
    > 加锁
    - tryLock() 
    > 尝试加锁
    - lockInterruptibly()
    > 响应中断加锁 
    - tryLock() 
    > 带超时的尝试加锁 
    - unLock()
    > 解锁 
    - newCondition()
    > 等待条件 
  - 标准 
     +  finanlly 释放锁 
    +  try 前获取锁 
  - 子类通过AQS(AbstractQueuedSynchronizer)队列来获取锁  
    - AQS作为抽象类，也是一个模板方法
    - 可重写的方法  
        - tryAcquire 独占获取锁
        - tryRelease 独占释放锁
        - tryAcquire 共享获取锁
        - tryReleaseShared 共享释放锁
        - isHeldExclusively 当前同步器是否在独占模式下被线程使用，一半用来表示是否被当前线程占用
    - 公共方法 用来设置同步状态
        - setState()
        - getState()
        - compareAndSetState() 
    - 主流程入口 
        - acquire()
        - acquireInterruptibly()
        - tryAcquireNanos()
        - release()
        - acquireShared()
        - acquireSharedInterruptibly()
        - tryAcquireSharedNanos()
        - releaseShared() 