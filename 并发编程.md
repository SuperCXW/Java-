# 并发编程
![并发包结构](./pic/J.U.C_2.png)

### 多线程创建
- Thread
- Runnable
- Callable
#### 锁
- synchroized
  可以修饰
  - 方法
  - 对象
  - 类
  - 静态方法
  方法和对象锁住对象锁
  类和静态方法段获得类锁
- Lock
- Reentrant
- ReentrantReadWriteLock
- StampedLock
- AbstractQueuedSynchronizer(AQS)

| 12 | 121 | sds |  
|:-- |:-- | :--|  
| 12 | 121 | sds |  
| 12 | 121 | sds |  
| 12 | 121 | sds |  
#### J.U.C
- atmoic
- locks
- collections
- Executor
  - ForkJoin
  - ThreadPoolExecutor
  - Executors
- sync
#### 并发的三个核心
- 分工
- 合并 
- 互斥  
  + 原子性  
    * 加锁
  + 有序性  
    * 编译器优化顺序影响有序性
      >
  + 可见性  
    * JMM  
      > 这里引入了JMM(Java Memeory Model) java内存模型，这个模型规定 变量都是放在主内存里面，线程修改的时候，要copy一个副本，这个副本修改完成后，刷新回主内存  
      >> 这里引入了一个并发问题，就是A拿走了，改了数据，B拿到的是没会写前的数据，这样就会发生可见性问题  
      >>>Happens-Before  
      >>>第一个操作的结果，对第二个数据可见
      >>>>程序顺序性规则  
      >>>>volatile变量规则  
      >>>>传递性规则  
      >>>>监视器锁规则  
      >>>>start()规则  
      >>>>join()规则  

      >> 内存屏障保护实现有序性，防止重排序
      >>> volatile写前插入一个storestore屏障
      >>> volatile写后插入一个storeLoad屏障`
      >>> volatile读前插入一个loadLoad屏障
      >>> volatile读后插入一个loadStore屏障
      >>>写一个volatile变量，实际上是向其他要读这个变量的线程发消息，让他们去主内存读
  + synchroized 只能保护当前对象，无法保护目标对象，这时候就需要锁整个class
    > 锁 普通同步方法,锁的是当前实例对象  静态方法,锁整个class   同步代码块，锁括号里面的obj
    
  + volatile 不保障原子性，所以写入值不依赖原址时，可以使用
  + 死锁
    - 条件
      >互斥  这个资源，只有唯一线程占用，排斥其他线程的占用  
      >请求和保持条件 持有一个资源，同时请求下一个资源，该资源已被其他线程持有  
      >不可剥夺条件 不使用完，不释放   
      >环路等待 必然存在进程，资源，环形链，所需的资源必然画成一个环  
      
      >> 可以尝试破坏 后三个条件
  + 等待/唤醒   
    + 管程
    > 管理共享变量以及对共享变量的操作，让他们支持并发
    >>数据和操作，一起入列enq 出列deq，多线程执行只能通过队列排队执行，入列出列，本身是互斥的
    + MESA模型
    > 